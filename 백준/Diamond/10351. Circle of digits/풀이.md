## 풀이
### 문제에 대한 이해
* 솔직히 말해서 저는 완벽하게 이 문제를 이해하지 못한 상태입니다. 그럼에도 이해한 부분을 최대한 풀이에 남겨 문제를 복기하고 그 과정에서 문제에 대한 이해도를 넓히고자 풀이를 작성합니다.
### 자명한 사실들
* 이 문제에는 잘 보이지 않지만 자명한 것들이 있습니다. 먼저 최댓값의 최소를 구하려면 문자열의 길이를 균등하게 잘라야 합니다. 균등하게 잘린 길이 중 그나마 가장 긴 것을 L이라 합시다.(문제가 요구하는 것도 결국 이 L입니다)
* 여기서 한 가지 더 감안해야 할 점이 있습니다. 일단 이 수열은 원형으로 이어져 있습니다. 그래서 균등하게 자르더라도 마디의 시작점을 알 수 없습니다. 그렇다면 생각을 전환해서 가장 길다고 가정한 L을 생각해 봅시다.
### 왜 시작점을 알아야 할까요?
**시작점을 알아야 최댓값의 최소를 찾을 수 있기 때문입니다.**
* L을 포함해 전체 문자열은 균등하게 나눴다고 가정하면, 시작점은 적어도 L의 어딘가에 포함되어 있다는 사실을 알 수 있습니다. 왜냐면 균등하게 잘린 마디 중 그나마 가장 긴 L에 시작점이 없다면 균등하게 자른다는 조건이 무너지기 때문입니다.(L≥⌈N/K⌉)
### 관점 전환
* 그렇다면 L(**L = (N-1)//K + 1**)의 어느 한 부분을 시작점이라 가정할 수 있습니다. 덕분에 굳이 모든 N을 전부 검사할 필요가 없습니다.

## 문제 유형
* 그리디 알고리즘, 문자열, 이분 탐색, 매개 변수 탐색, 접미사 배열과 LCP 배열
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N log²N)$
* 공간복잡도: $\mathcal{O}(N)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def SA(s):
    n = len(s); m = max(n, 1024) + 1
    sa = list(range(n)); nr = [0] * (2*n); idx = [0] * n; r = [0] * (2*n)
    for i in range(n): r[i] = int(s[i]) + 1

    d = 1 
    while d < n:
        cmp = lambda i, j: (
            r[i] < r[j] or (r[i] == r[j] and r[i+d] < r[j+d])
        )
        cnt = [0] * m
        for i in range(n): cnt[r[i+d]] += 1
        for i in range(1, m): cnt[i] += cnt[i-1]
        for i in range(n-1, -1, -1): 
            cnt[r[i+d]] -= 1
            idx[cnt[r[i+d]]] = i
        cnt = [0] * m
        for i in range(n): cnt[r[i]] += 1
        for i in range(1, m): cnt[i] += cnt[i-1]
        for i in range(n-1, -1, -1): 
            cnt[r[idx[i]]] -= 1
            sa[cnt[r[idx[i]]]] = idx[i]
        nr[sa[0]] = 1
        for i in range(1, n): nr[sa[i]] = nr[sa[i-1]] + cmp(sa[i-1], sa[i])
        for i in range(n): r[i] = nr[i]
        d <<= 1
    global rev, ret
    rev = [0] * (n//2); ret = [0] * (n//2); ii = 0
    for i in sa:
        if i < n//2:
            rev[i] = ii
            ret[ii] = i; ii +=1

def main():
    n, k = map(int, input().split())
    s = input(); s = s + s
    if(n==k):
        ans = 0
        for i in range(n): ans = max(ans, int(s[i]))
        print(ans)
        return 0
    SA(s)
    l = 0; r = n
    while l < r:
        mid = l+r>>1
        flag = False
        for x in range((n-1)//k+1):
            cnt = 0; now = x
            while now < x+n:
                if rev[now%n] <= rev[ret[mid]]: now += 1
                now += (n-1)//k
                cnt += 1
            if cnt <= k:
                flag = True
                break
        if flag: r = mid
        else: l = mid + 1
    print(s[ret[l]: ret[l]+(n-1)//k+1])
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;

vector<int> ret, rev;

void SA(string s){
	int n = s.size(); int m = max(n, 1024)+1;
	vector<int> sa(n), r(2*n), nr(2*n), cnt(m), idx(n);
	for(int i = 0; i < n; i++) sa[i] = i, r[i] = s[i]-'0'+1;
	for(int d = 1; d < n; d <<= 1){
		auto cmp = [&](int i, int j){
			return r[i] < r[j] || r[i] == r[j] && r[i+d] < r[j+d];
		};
		for(auto& i : cnt) i = 0;
		for(int i = 0; i < n; i++) cnt[r[i+d]]++;
		for(int i = 1; i < m; i++) cnt[i] += cnt[i-1];
		for(int i = n-1; i>=0; i--) idx[--cnt[r[i+d]]] = i;
		for(auto& i : cnt) i = 0;
		for(int i = 0; i < n; i++) cnt[r[i]]++;
		for(int i = 1; i < m; i++) cnt[i] += cnt[i-1];
		for(int i = n-1; i>=0; i--) sa[--cnt[r[idx[i]]]] = idx[i];
		nr[sa[0]] = 1;
		for(int i = 1; i < n; i++) nr[sa[i]] = nr[sa[i-1]] + cmp(sa[i-1], sa[i]);
		for(int i = 0; i < n; i++) r[i] = nr[i];
	}
	ret.resize(n/2); rev.resize(n/2); int ii = 0;
	for(int i : sa) if(i < n/2){
		rev[i] = ii;
		ret[ii++] = i;
	}
	return;
}

int main(){
	cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);
	int n, k; cin >> n >> k;
	string s; cin >> s; s = s+s;
	if(n == k){
		int ans = 0;
		for(int i = 0; i < n; i++) ans = max(ans, s[i]-'0');
		return !(cout << ans);
	}
	SA(s);
	int l = 0, r = n;
	while(l < r){
		int mid = l+r>>1;
		bool flag = 0;
		for(int x = 0; x < (n-1)/k+1; x++){
			int cnt = 0; int now = x;
			while(now < x+n){
				if(rev[now%n] <= rev[ret[mid]]) now++;
				now += (n-1)/k;
				cnt++;				
			}
			if(cnt <= k){
				flag = 1;
				break;
			}
		}
		if(flag) r = mid;
		else l = mid+1;
	}
	cout << s.substr(ret[l], (n-1)/k+1);
}
```
