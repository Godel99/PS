# 풀이
### 문제에 대한 이해
* 솔직히 말해서 저는 완벽하게 이 문제를 이해하지 못한 상태입니다. 그럼에도 이해한 부분을 최대한 풀이에 남겨 문제를 복기하고 그 과정에서 문제에 대한 이해도를 넓히고자 풀이를 작성합니다.
### 목적
* **“원형 문자열에서, 최댓값을 최소로 만드는 ‘시작점’을 찾는다.”**
### 자명한 사실들
* 이 문제에는 잘 보이지 않지만 자명한 것들이 있습니다. 먼저 최댓값의 최소를 구하려면 문자열의 길이를 균등하게 잘라야 합니다. 균등하게 잘린 길이 중 그나마 가장 긴 것을 L이라 합시다.
* 여기서 한 가지 더 감안해야 할 점이 있습니다. 일단 이 수열은 원형으로 이어져 있습니다. 그래서 균등하게 자르더라도 마디의 시작점을 알 수 없습니다. 그렇다면 생각을 전환해서 가장 길다고 가정한 L을 생각해 봅시다.
### 왜 시작점을 알아야 할까요?
**시작점에서부터 균등하게 자른 결과가 우리가 구하는 최댓값의 최소이기 때문입니다.**
* L을 포함해 전체 문자열은 균등하게 나눴다고 가정하면, 시작점은 적어도 L의 어딘가에 포함되어 있다는 사실을 알 수 있습니다. 왜냐면 균등하게 잘린 마디 중 그나마 가장 긴 L에 시작점이 없다면 균등하게 자른다는 조건이 무너지기 때문입니다.(L≥⌈N/K⌉)
### 관점 전환
* 그렇다면 
𝐿=(𝑁−1)//𝐾+1 길이의 구간 중 어느 한 위치를 시작점으로 가정할 수 있습니다. 그러므로 시작점을 모든 N개의 위치에서 탐색할 필요가 없습니다.
* 시작점을 고정하면, 마디의 길이를 기준으로 문자열을 나누게 됩니다.
* 이때 마디의 길이가 길어질수록 필요한 마디 수는 줄어들고, 길이가 짧아질수록 마디 수는 늘어나는 단조성을 가집니다.
* 따라서 문제는 **“주어진 길이를 기준으로 K개 이하의 마디로 나눌 수 있는가?”** 라는 판별 문제로 전환됩니다.
* 이 판별은 각 단계에서 마디를 가능한 한 길게 잡는 **그리디** 선택으로 해결할 수 있습니다. 즉, 주어진 길이에서의 최소 마디 수를 항상 계산할 수 있습니다.
* 판별 결과는 길이에 대해 단조성을 가지므로, **이분 탐색**을 이용해 최적의 길이를 빠르게 찾을 수 있습니다.
### 그리디 판별과 목적
* 위에 관점을 다시 정리하자면 그리디로 판별한 결과는 단조성을 띄게 되며, 단조 구조에서 이분 탐색을 이용해 최적의 시작점을 찾아내는 것이 목적입니다. 그 뒤 시작점을 기준으로 균등한 마디로 자르면 그것이 정답이 되기 때문입니다.
* 그렇다면 판별을 어떻게 할 것인가가 문제입니다. 그런데 실은 간단합니다. 목적은 가장 최소의 최댓값을 찾는 것이기에 문자열을 균등하게 자른 뒤 **정렬** 후 마디가 가장 긴 것 중 첫 시작이 가장 작은 것을 찾는 겁니다.
* 그러나 문자열 자체를 정렬하는 것도 괜찮지만 우리는 좀 더 효율적 방법을 생각해 봅시다.
### Suffix Array + LCP(접미사 배열과 LCP 배열)
* 문자열 정렬을 하는데 있어 먼저 필요한 도구가 Suffix Array + LCP 입니다.
* 이것은 간단하게 말해 문자열의 접미사를 정수 단위로 바꿔 다시 저장한 배열을 말합니다. 문자열의 접미사를 이용해 시작점을 정수로 바꿔 배열에 저장하고 , LCP(Longest Common Prefix, 최장 공통 접두사)를 이용해 얼마나 공통된 영역을 가지고 있는가를 표현합니다.
* **참고**   
*(LCP는 이전 공통 접두사를 이용해 손쉽게 현재 값을 구할 수 있습니다. 여기서 쓰이는 알고리즘이 Kasai 알고리즘입니다. 이 문제에서는 LCP 배열을 직접 사용하지는 않지만, Suffix Array의 순서가 곧 문자열 비교 결과를 의미한다는 점에서 LCP 개념이 그 배경이 됩니다.)*
* Suffix Array + LCP는 보통 대규모 문자열 데이터를 질의할 때 쓰이는 자료구조입니다.
* 예를 들어 abc, ab 등 문자열은 중복된 구간이 많은 데이터 구조입니다. a라는 시작점을 저장 후 bc라는 중복된 결과만 가지고 있으면 abc, bc를 전부 저장할 필요 없이 abc, bc를 구별할 수 있게 됩니다. 즉, 문자열 자체가 아니라 정수 단위로 메모리를 효율적으로 관리함과 동시에 탐색이나 정렬도 간단하게 할 수 있게 됩니다.
### 기수 정렬과 계수 정렬
* 문자열 마디를 어떻게 관리할지 정해졌다면 이제 정렬하는 방법을 다시 생각해 봅시다. 우리는 문자열 마디를 정수로 바꾸는 Suffix Array + LCP 배열을 가지고 있습니다. 그렇다면 정수 단위 정렬을 손쉽게 할 수 있는 게 무엇일까요? 그게 바로 **기수정렬**입니다.
* 기수 정렬: 데이터를 구성하는 **자릿수**를 기준으로 정렬하는 방식, 계수 정렬: 데이터의 값을 직접 비교하지 않고, 각 숫자(0~9)가 몇 번 등장하는지 개수를 세어 정렬하는 방식
* 위에 짧게 정의와 설명을 했지만 기수 정렬은 계수 정렬을 보완하고자 나온 정렬이며 기수 정렬 안에는 계수 정렬이 작동합니다.
### 기수 정렬과 doubling 알고리즘 + Suffix Array + LCP
* 잠시 다시 정리를 하자면 Suffix Array를 통해 문자열을 정수단위로 바꾸고, 이를 정렬하는데 기수 정렬을 쓰겠다까지 왔습니다. 
* 여기서 우리는 문자열의 접미사를 정수단위로 바꾸는데 한 글자단위가 아닌 $2^k$단위로 묶어봅시다. 여기서 쓰이는 것이 doubling 알고리즘입니다. 즉, 문자열 접미사를 $2^k$단위로 묶어 우리는 자릿수 2개 정수 단위 문제로 환원할 수 있습니다. 더불어 doubling 알고리즘 진짜 핵심은 이전 정렬 데이터를 이용해 앞에 정렬 데이터를 정렬하는데 있습니다.
* 기수 정렬은 이제 *r[i], r[i+d]*(r은 문자열 접미사의 랭크)이라는 자릿수로 정렬을 합니다. 기수 정렬은 안정 정렬이 필요하므로 뒷자리부터 정렬을 합니다.
### 결과
* 이제 정렬 후 그리디를 이용해 이분 탐색을 진행 후 최적의 시작점을 찾고, 그 시작점으로부터 𝐿=(𝑁−1)//𝐾+1의 길이를 출력하면 그게 바로 정답입니다.
## 코드 해부
```python
d = 1 
while d < n:
    cmp = lambda i, j: (
        r[i] < r[j] or (r[i] == r[j] and r[i+d] < r[j+d])
    )
    cnt = [0] * m
    for i in range(n): cnt[r[i+d]] += 1
    for i in range(1, m): cnt[i] += cnt[i-1]
    for i in range(n-1, -1, -1): 
        cnt[r[i+d]] -= 1
        idx[cnt[r[i+d]]] = i
    cnt = [0] * m
    for i in range(n): cnt[r[i]] += 1
    for i in range(1, m): cnt[i] += cnt[i-1]
    for i in range(n-1, -1, -1): 
        cnt[r[idx[i]]] -= 1
        sa[cnt[r[idx[i]]]] = idx[i]
    nr[sa[0]] = 1
    for i in range(1, n): nr[sa[i]] = nr[sa[i-1]] + cmp(sa[i-1], sa[i])
    for i in range(n): r[i] = nr[i]
    d <<= 1
```
* while문은 doubling 알고리즘을 시작하는 부분입니다.
* cnt 배열은 계수 정렬에 필요한 개수를 저장하는 배열입니다.
* 3개의 for문의 의미(r[i+d]자릿수)
1. 각 문자의 개수를 새는 것입니다.
2. 그 개수를 누적합니다.
3. 누적합을 이용해 idx에 정렬을 합니다.
* 마찬가지로 r[i] 자릿수에도 동일하게 계수정렬을 하고 두 자릿수(r[i+d], r[i])를 합쳐 기수 정렬을 합니다.
* sa에는 정렬된 정보가 들어가 있지만, 동일값에 대한 정보가 부족합니다. 즉, sa 자체가 rank는 아닙니다. 
* 그래서 cmp람다함수를 통해서 이전 값과 비교를 해 다시 한번 정렬을 합니다. 왜 이전 값과 다시 비교를 하냐면 sa은 정렬이 되어 있기 때문에 비슷한 값끼리 모여있습니다. 그러기에 동일값을 구분하기 위해선 이전 비교만으로 충분합니다.
* 그렇게 구한 것을 doubling 알고리즘의 핵심인 이전 정렬 값을 이용해 앞에 정렬에 사용하기 위해서 r = nr 하게 됩니다.
```python
global rev, ret
rev = [0] * (n//2); ret = [0] * (n//2); ii = 0
for i in sa:
    if i < n//2:
        rev[i] = ii
        ret[ii] = i; ii +=1
```
* 최종적으로 sa에는 접미사가 정수 형태로 정렬이 완료되어 있을 겁니다.
* 이제 LCP를 할 차례입니다. 물론 여기서 LCP 배열이 쓰이지는 않지만 ret, rev를 통해서 LCP를 구현을 합니다.
* 변수 설명
```
ret = “압축된 LCP 정보”
rev = “순서 기준”
```
* ret은 말 그대로 sa 의 정렬된 정보를 가지고 있지만 인덱스 번호를 가지고 있지 않습니다. rev가 바로 그 인덱스를 저장하는 공간입니다.
* 덕분에 LCP는 공통 접두사를 빠르게 찾아가는 게 목적이기에 그 역활을 rev가 하게 됩니다.(다른 방법도 있을 수 있겠지만 배열의 인덱스를 접근하는 게 가장 빠름)
```python
if(n==k):
    ans = 0
    for i in range(n): ans = max(ans, int(s[i]))
    print(ans)
    return 0
```
* n==k이면 모든 문자가 마디가 되므로 그 중 가장 높은 값이 정답입니다.
```python
SA(s)
l = 0; r = n
while l < r:
    mid = l+r>>1
    flag = False
    for x in range((n-1)//k+1):
        cnt = 0; now = x
        while now < x+n:
            if rev[now%n] <= rev[ret[mid]]: now += 1
            now += (n-1)//k
            cnt += 1
        if cnt <= k:
            flag = True
            break
    if flag: r = mid
    else: l = mid + 1
print(s[ret[l]: ret[l]+(n-1)//k+1])
```
* SA로 접두사 정렬을 합니다.
* 이분 탐색을 하는 while문입니다.
* for문은 L의 범위 내에서 시작점을 찾는 것입니다.
* rev가 바로 인덱스이고 순위를 나타내므로 그것을 통해 그리디로 길이를 늘리면서 최소 마디를 구하게 됩니다.
* 마지막에 l이 시작점의 인덱스가 되며 ret[l]에서부터 (n-1)//k+1까지 길이를 출력하면 그게 바로 정답입니다.
## 문제 유형
* 그리디 알고리즘, 문자열, 이분 탐색, 매개 변수 탐색, 접미사 배열과 LCP 배열
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N log²N)$
* 공간복잡도: $\mathcal{O}(N)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def SA(s):
    n = len(s); m = max(n, 1024) + 1
    sa = list(range(n)); nr = [0] * (2*n); idx = [0] * n; r = [0] * (2*n)
    for i in range(n): r[i] = int(s[i]) + 1

    d = 1 
    while d < n:
        cmp = lambda i, j: (
            r[i] < r[j] or (r[i] == r[j] and r[i+d] < r[j+d])
        )
        cnt = [0] * m
        for i in range(n): cnt[r[i+d]] += 1
        for i in range(1, m): cnt[i] += cnt[i-1]
        for i in range(n-1, -1, -1): 
            cnt[r[i+d]] -= 1
            idx[cnt[r[i+d]]] = i
        cnt = [0] * m
        for i in range(n): cnt[r[i]] += 1
        for i in range(1, m): cnt[i] += cnt[i-1]
        for i in range(n-1, -1, -1): 
            cnt[r[idx[i]]] -= 1
            sa[cnt[r[idx[i]]]] = idx[i]
        nr[sa[0]] = 1
        for i in range(1, n): nr[sa[i]] = nr[sa[i-1]] + cmp(sa[i-1], sa[i])
        for i in range(n): r[i] = nr[i]
        d <<= 1
    global rev, ret
    rev = [0] * (n//2); ret = [0] * (n//2); ii = 0
    for i in sa:
        if i < n//2:
            rev[i] = ii
            ret[ii] = i; ii +=1

def main():
    n, k = map(int, input().split())
    s = input(); s = s + s
    if(n==k):
        ans = 0
        for i in range(n): ans = max(ans, int(s[i]))
        print(ans)
        return 0
    SA(s)
    l = 0; r = n
    while l < r:
        mid = l+r>>1
        flag = False
        for x in range((n-1)//k+1):
            cnt = 0; now = x
            while now < x+n:
                if rev[now%n] <= rev[ret[mid]]: now += 1
                now += (n-1)//k
                cnt += 1
            if cnt <= k:
                flag = True
                break
        if flag: r = mid
        else: l = mid + 1
    print(s[ret[l]: ret[l]+(n-1)//k+1])
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;

vector<int> ret, rev;

void SA(string s){
	int n = s.size(); int m = max(n, 1024)+1;
	vector<int> sa(n), r(2*n), nr(2*n), cnt(m), idx(n);
	for(int i = 0; i < n; i++) sa[i] = i, r[i] = s[i]-'0'+1;
	for(int d = 1; d < n; d <<= 1){
		auto cmp = [&](int i, int j){
			return r[i] < r[j] || r[i] == r[j] && r[i+d] < r[j+d];
		};
		for(auto& i : cnt) i = 0;
		for(int i = 0; i < n; i++) cnt[r[i+d]]++;
		for(int i = 1; i < m; i++) cnt[i] += cnt[i-1];
		for(int i = n-1; i >= 0; i--) idx[--cnt[r[i+d]]] = i;
		for(auto& i : cnt) i = 0;
		for(int i = 0; i < n; i++) cnt[r[i]]++;
		for(int i = 1; i < m; i++) cnt[i] += cnt[i-1];
		for(int i = n-1; i >= 0; i--) sa[--cnt[r[idx[i]]]] = idx[i];
		nr[sa[0]] = 1;
		for(int i = 1; i < n; i++) nr[sa[i]] = nr[sa[i-1]] + cmp(sa[i-1], sa[i]);
		for(int i = 0; i < n; i++) r[i] = nr[i];
	}
	rev.resize(n/2); ret.resize(n/2); int ii = 0;
	for(int i : sa) if(i < n/2){
		rev[i] = ii;
		ret[ii++] = i;
	}
}
int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
	int n, k; cin >> n >> k;
	string s; cin >> s; s = s+s;
	if(n == k){
		int ans = 0;
		for(int i = 0; i < n; i++) ans = max(ans, s[i]-'0');
		return !(cout << ans);
	}
	SA(s);
	int l = 0, r = n;
	while(l < r){
		int mid = l+r>>1;
		bool flag = 0;
		for(int x = 0; x < (n-1)/k+1; x++){
			int cnt = 0; int now = x;
			while(now < x+n){
				if(rev[now%n] <= rev[ret[mid]]) now++;
				now += (n-1)/k;
				cnt++;			
			}
			if(cnt <= k){
				flag = 1;
				break;
			}
		}
		if(flag) r = mid;
		else l = mid+1;
	}
	cout << s.substr(ret[l], (n-1)/k+1);
}
```
