# 풀이
### 다각형 조건
길이가 $a \leq b \leq c$ 일 때 삼각형이 만족하려면 $a + b \gt c$ 어야 합니다. 다각형 경우도 가장 긴 변의 길이보다 나머지 변의 길이의 합이 크면 다각형을 만족합니다.
### DP 정의하기
일단 주어진 선분의 길이를 오름차순 정렬합니다. 그러면 어떤 선분을 가장 긴 변으로 고정했을 때 그 앞에 있는 선분 중 K-1개를 골라 합을 이번 선분의 길이를 초과하게 만드는 방법의 수를 세는 것으로 문제를 해결할 수 있습니다.
* $dp[k][l]:$ $k$개의 선분을 골라 길이의 합을 $l$로 만드는 경우의 수
### 배낭 문제
문제의 조건에서 다각형의 조건이 서로 다를 경우는 서로 다른 선분을 사용했을 경우입니다. 따라서, 배낭 문제와 유사합니다. 이럴 경우 dp는 정방향이 아닌 역방향으로 적용해 가야 이전 선분을 제외해 문제 조건을 만족합니다.
### INF 처리
일반적으로 k-1개의 선분에서 모든 선분에 대한 조합을 구한 후 다격형의 성립 되지 않는 경우의 수를 제외하면 정답을 구할 수 있습니다.

그러나 좀 더 효율적 방법을 찾아본다면, **k-1개 선분의 합이 최대 선분 l보다 큰 것을 모두 더해 inf영역에 몰아준다면 inf을 이상을 무시할 수 있어서** 훨씬 더 빠르게 정답을 구할 수 있습니다.
## 문제 유형
* 다이나믹 프로그래밍, 정렬, 기하학, 배낭 문제
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(NKL)$
* 공간복잡도: $\mathcal{O}(KL)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def main():
    n = int(input())
    a = sorted(map(int, input().split()))
    k = int(input())
    maxl = a[-1]+1; 
    dp = [[0] * (maxl+1) for _ in range(k+1)]
    dp[0][0] = 1
    for i in range(n):
        for j in range(maxl, -1, -1):
            if j <= a[i]: break
            dp[k][maxl] += dp[k-1][j]
        for l in range(k-2, -1, -1):
            for j in range(maxl, -1 , -1):
                dp[l+1][min(maxl, j+a[i])] += dp[l][j]
    print(dp[k][maxl])
if __name__ == "__main__":
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
	cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);
	int n; cin >> n;
	vector<int> a(n);
	for(int i = 0; i < n; i++) cin >> a[i];
	sort(a.begin(), a.end());
	int k; cin >> k;
	int maxl = a[n-1]+1;
	vector<vector<ll>> dp(k+1, vector<ll>(maxl+1, 0));
	dp[0][0] = 1;
	for(int i = 0; i < n; i++){
		for(int j = maxl; j >= 0; j--){
			if(j <= a[i]) break;
			dp[k][maxl] += dp[k-1][j];
		}
		for(int l = k-2; l >= 0; l--){
			for(int j = maxl; j >= 0; j--){
				dp[l+1][min(maxl, j+a[i])] += dp[l][j];
			}
		}
	}
	cout << dp[k][maxl];
}
```
