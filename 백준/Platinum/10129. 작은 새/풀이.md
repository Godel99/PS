## 풀이
### 관점전환
* **dp[i] = i번째 나무에 도착했을 때의 최소 피로도**라는 기준을 먼저 잡습니다.
* 모든 나무에 대해서 dp를 구해 최소의 피로도를 구할 수도 있지만 비효율입니다.
* 그러기에 피로도가 가장 낮은 걸 우선으로 합니다. 만약 피로도가 동일하다면 어차피 높이가 아무리 높아도 피로도는 1만 쌓이므로 가장 높은 나무를 우선으로 합니다.
### 단조성 유지(Monotonic Queue)
* 이 문제는 나무를 지나갈수록 피로도는 쌓일 수 밖에 없는 단조 구조입니다.
* 그렇다면 현재 상태의 피로도와 오른쪽으로 이동하면서 가장 뒤에 나무에서의 피로도와 높이를 기준으로 뒤에 나무를 제거해 간다면 단조성을 유지할 수 있습니다.
* 왜냐면 어차피 현재보다 못하다면 뒤에 나무는 제거하는 게 맞기 때문입니다.
* 이를 통해 덱의 맨 앞에는 최소의 피로도 상태를 유지합니다.
* 또한 앞으로 나아갈 때마다 현재에 도달하지 못하는 앞의 덱도 미리미리 제거해 줍니다.
## 문제 유형
* 다이나믹 프로그래밍, 자료 구조, 덱, 덱을 이용한 구간 최댓값 트릭, 덱을 이용한 다이나믹 프로그래밍
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(q × n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
* CPython에선 시간초과로 제출이 불가능합니다. 반복문마다 덱, 객체를 여러 번 접근하기에 시간초과가 날 수 밖에 없다고 합니다.
### C++
```c++
#include<bits/stdc++.h>
using namespace std;

struct st{
    int idx, val, h;
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    int q; cin >> q;

    while (q--){
        deque<st> dp;
        int k; cin >> k;

        dp.push_back({0,0,h[0]});

        for (int i = 1; i < n; i++){
            while (dp.size() && dp.front().idx + k < i) dp.pop_front();
            int now = dp.front().val + (bool)(dp.front().h <= h[i]);
            while (dp.size() && (dp.back().val > now || dp.back().val == now && dp.back().h <= h[i])) dp.pop_back();
            dp.push_back({i, now, h[i]});
        }
        cout << dp.back().val << endl;
    }
}
```
