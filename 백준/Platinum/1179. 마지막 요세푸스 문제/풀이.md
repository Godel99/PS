# 풀이
<p align="center"/><img width="295" height="294" alt="다운로드" src="https://github.com/user-attachments/assets/6539559b-bed3-47a6-abfc-32221e6361c9">

### 문제 요약
요세푸스의 순열을 구하는 것이 아니라 마지막 생존자를 구하는 문제입니다. 마찬가지로 요세푸스 순열을 구해서 마지막 인덱스 값을 출력해도 되지만, $n$의 범위가 클 때는 시간초과가 날 수 있습니다.

### $n$을 줄일 수 없을까?
요세푸스 문제를 **수학적으로 접근**해 보면, **한 사람이 죽고 그 다음은 더 작은 요세푸스 문제가 된다**는 점을 알 수 있습니다.

**마지막 생존자의 번호를 구하는 게 최종 목표**이기에 굳이 한 사람씩 죽는 경우만 생각할 게 아니라 한 바퀴를 돌았을 경우를 생각해 봅시다.

마찬가지로 **한 바퀴를 돌았을 경우에 $n/k$명이 죽는다는 사실**을 알 수 있습니다. 따라서, $n-n/k$을 통해서 $n$을 획기적으로 줄여갈 수 있습니다.(단, $k$가 작을 경우)

### 점화식
요세푸스 문제의 점화식을 표현하면 아래와 같습니다.

$$
g(n,\ k) = \begin{cases}
0 & \mathrm{if} \ n=1 \\ 
\left( g(n-1,\ k)+k \right ) \mod{n} &\mathrm{if} \ 1 < n < k \\ 
\mathrm{for} \ h := g(n - \lfloor \frac{n}{k} \rfloor,\ k ) - \left( n \mod{k} \right ), \quad \begin{cases} 
h+n & \mathrm{if}\ h < 0 \\
h+ \lfloor \frac{h}{k-1} \rfloor & \mathrm{otherwise}
 \end{cases} & \mathrm{otherwise}
\end{cases}
\ ( 0-based\ index\ 기준)
$$
### 분할 정복
줄이는 과정은 **재귀**를 이용하면 좋습니다. 왜냐면 재귀는 결국 큰 문제를 더 작은 문제로 쪼개서 해결할 때 유리하기 때문입니다.

문제는 재귀를 반복할 때마다 시작점과 번호가 바뀐다는 것입니다. 따라서 **시작점과 원래 위치의 번호를 복원**해줘야 합니다.
### 시작점 복원
$(n \mod{k})$는 **한 바퀴를 돌고 난 뒤 마지막으로 제거된 사람 뒤에 남은 인원수**를 의미합니다. 마지막 죽은 사람의 다음 사람이 시작점이 되기에 그만큼을 왼쪽 회전해 시작점을 맞춰주는 겁니다.
### 원위치 복원

$$
h = \begin{cases} h + n & \text{if } h < 0 \\ 
h+ \lfloor \frac{h}{k-1} \rfloor & \mathrm{otherwise}
\end{cases}
$$

$h < 0$ 경우는 한 바퀴를 돌고 나머지 인원이 남아 있다는 뜻입니다. $+n$ 더해줘서 원위치 시켜줍니다.

$h \ge 0$ 경우는 k명을 제거했고 죽은 사람의 자리를 뒤에서 한칸씩 채우게 됩니다. 원래 인덱스를 복원하는 게 목적이기에 $\lfloor \frac{h}{k-1} \rfloor$만큼을 다시 밀어줍니다.

## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(k log n)$
* 공간복잡도: $\mathcal{O}(k log n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

sys.setrecursionlimit(10**7)

def josephus(n, k):
    if n == 1: return 0
    if n < k: return (josephus(n-1, k)+k)%n
    h = josephus(n-n//k, k) - n%k
    if h < 0: return h+n
    return h+h//(k-1)

def main():
    n, k = map(int, input().split())
    print(n) if k == 1 else print(josephus(n,k)+1)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def josephus(n, k):
    i = 1
    ans = 0
    while i < n:
        j = (i-ans-1)//(k-1)+1
        if i + j > n: break
        ans = (ans+k*j)%(i+j)
        i += j
    ans += (n-i)*k
    return ans

def main():
    n, k = map(int, input().split())
    print(n) if k == 1 else print(josephus(n,k)+1)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll josephus(ll n, ll k){
    if(n == 1) return 0;
    if(n < k) return (josephus(n-1, k)+k)%n;
    ll h = josephus(n-n/k, k) - n%k;
    if(h < 0) return h+n;
    return h+h/(k-1);
}

int main(){
    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);
    ll n, k; cin >> n >> k; if(k == 1) cout << n; else cout << josephus(n, k)+1;
}
```
