# 풀이
간단하게 큐를 이용해 요세푸스 문제를 해결할 수 있지만, 이 문제의 경우 입력값의 범위가 매우 큽니다.(1 ≤ N ≤ 10<sup>15</sup>, 1 ≤ K ≤ 90, $\mathcal{O}(n)$ 경우 TLE)

여기선 수학적 접근을 통해 $n$을 크기를 줄일 수 있습니다. 그 과정은 재귀를 이용해서 풀어봅시다.
### 수학적 접근
요세푸스 문제를 수학적 접근을 해본다면, 한 바퀴를 돌았을 경우 그 다음은 좀 더 작은 요세푸스 문제가 된다는 점을 알 수 있습니다. 이를 점화식으로 표현하면 아래와 같습니다.

$$f(n,k)=(f(n−1,k)+k)\ mod\ n$$
### $n$ 줄이기
$n<k$ 경우 위 점화식을 이용해 간단히 해결하면 됩니다.


문제는 $n>k$이 클 경우 이를 어떻게 줄일 수 있느냐입니다. 다행히도 한 바퀴를 돌 경우 $n/k$명이 죽는다는 사실을 착안하여 $n-n/k$로 $n$을 줄여갈 수 있습니다.( $\mathcal{O}(k log n)$ )
### 원위치 조정
여기서 한가지 집고 가야할 점은 $n/k$를 줄이고 나서 살아남은 사람들의 위치를 다시 조정해줘야 합니다. $x$를 살아남은 사람의 위치라고 한다면 $x+x/(k-1)$만큼 이동을 시켜줍니다.
### 시작점 조정
이제 살아남은 사람들의 위치를 조정했다면, 다음은 시작점을 원위치 시켜줘야 합니다. 그래서 다시 $n\mod\ k$ 만큼 시작점을 이동시킵니다.
## 문제 유형
* 수학, 다이나믹 프로그래밍, 재귀
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(k log n)$
* 공간복잡도: $\mathcal{O}(k log n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

sys.setrecursionlimit(10**7)

def josephus(n, k):
    if n == 1: return 0
    if n < k: return (josephus(n-1, k)+k)%n
    l = josephus(n-n//k, k) - n%k
    if l < 0: return l+n
    return l+l//(k-1)

def main():
    n, k = map(int, input().split())
    print(n) if k == 1 else print(josephus(n,k)+1)
if __name__ == '__main__':
    main()
```
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

sys.setrecursionlimit(10**7)

def josephus(n, k):
    if n == 1: return 0
    if n < k: return dp[n]
    l = josephus(n-n//k, k) - n%k
    if l < 0: return l+n
    return l+l//(k-1)

def main():
    n, k = map(int, input().split())
    global dp
    dp = [0] * k
    for i in range(1, k): dp[i] = (dp[i-1]+k)%i
    print(n) if k == 1 else print(josephus(n,k)+1)
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll josephus(ll n, ll k){
    if(n == 1) return 0;
    if(n < k) return (josephus(n-1, k)+k)%n;
    ll l = josephus(n-n/k, k) - n%k;
    if(l < 0) return l+n;
    return l+l/(k-1);
}

int main(){
    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);
    ll n, k; cin >> n >> k; if(k == 1) cout << n; else cout << josephus(n, k)+1;
}
```
