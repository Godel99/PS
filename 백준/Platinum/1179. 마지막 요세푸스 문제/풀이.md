# 풀이
<p align="center"/><img width="295" height="294" alt="다운로드" src="https://github.com/user-attachments/assets/6539559b-bed3-47a6-abfc-32221e6361c9">

### 문제 요약
이번 문제는 큐를 이용해서 요세푸스의 순열을 구하는 것이 아니라 마지막 생존자를 구하는 문제입니다. 마찬가지로 요세푸스 순열을 구해서 마지막 인덱스 값을 출력해도 되지만, $n$의 범위가 클 때는 시간초과가 날 수 있습니다.

### 수학적 접근
요세푸스 문제를 수학적 접근을 해본다면, 한 사람이 죽은 다음은 좀 더 작은 요세푸스 문제가 된다는 점을 알 수 있습니다. 이를 전체 점화식으로 나타내면 아래와 같습니다.
$$
g(n,\ k) = \begin{cases}
0 & \mathrm{if} \ n=1 \\ 
\left( g(n-1,\ k)+k \right ) \mod{n} &\mathrm{if} \ 1 < n < k \\ 
\mathrm{for} \ h := g(n - \lfloor \frac{n}{k} \rfloor,\ k ) - \left( n \mod{k} \right ), \quad \begin{cases} 
h+n & \mathrm{if}\ h < 0 \\
h+ \lfloor \frac{h}{k-1} \rfloor & \mathrm{otherwise}
 \end{cases} & \mathrm{otherwise}
\end{cases}
\ (0-index 기준)
$$
### $n$을 줄일 수는 없을까?
$n<k(1 ≤ K ≤ 90)$ 경우 $n$이 크지 않아 $$g(n, k)=(g(n-1,\ k)+k) \mod{n} \ \mathrm{if} \ 1 < n < k$$ 점화식을 이용하면 됩니다.

문제는 $n>k(1 ≤ N ≤ 10^{15})$이 클 경우 $n$을 어떻게 줄일 수 있느냐입니다. 다행히도 한 바퀴를 돌 경우 $n/k$명이 죽는다는 사실을 착안하여 $n-n/k$로 $n$을 줄여갈 수 있습니다.

줄이는 과정은 **재귀**를 이용하면 좋습니다. 왜냐면 재귀는 결국 큰 문제를 더 작은 문제로 쪼개서 해결할 때 유리하기 때문입니다.(분할정복+재귀)

그런데 우리가 구하고자 하는 것은 **마지막으로 살아남는 사람의 번호**입니다. 

중요한 것은 **매번 $n/k$명이 죽을 때마다 시작 위치와 사람들의 번호가 바뀐다는 사실**입니다. $n/k$명이 죽을 때마다 원위치 복원작업을 해줘야 합니다.
### 시작점 복원
원위치를 복원하기 앞서 회전 복원, 즉 시작점부터 찾아줍시다. 왜 시작점부터 찾아주냐면 시작점을 알아야 다시 원래 번호를 찾아줄 수 있기 때문입니다.

시작점은 **마지막 죽은 사람의 다음 위치가 시작점**이 됩니다. 그렇다면 마지막 사람이 죽고 그 뒤에 $n\ mod\ k$명이 남게 됩니다. 따라서 그 부분을 빼줘서 시작점을 원위치 시킵니다. 
### 원위치 복원
시작점 찾기 위해 회전 복원을 시켰다면, 다음은 원래 번호를 찾아줘야 합니다. $x$를 살아남은 사람의 위치라고 한다면 $x+x/(k-1)$만큼 이동을 시켜줍니다.

$x$의 원 위치는 생존자 $x$명 + 이전 $(k-1)$의 제거자 수이기 때문에 $x+x/(k-1)$이 성립합니다.
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(k log n)$
* 공간복잡도: $\mathcal{O}(k log n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

sys.setrecursionlimit(10**7)

def josephus(n, k):
    if n == 1: return 0
    if n < k: return (josephus(n-1, k)+k)%n
    h = josephus(n-n//k, k) - n%k
    if h < 0: return h+n
    return h+h//(k-1)

def main():
    n, k = map(int, input().split())
    print(n) if k == 1 else print(josephus(n,k)+1)
    return 0
if __name__ == '__main__':
    sys.exit(main())
```
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def josephus(n, k):
    i = 1
    ans = 0
    while i < n:
        j = (i-ans-1)//(k-1)+1
        if i + j > n: break
        ans = (ans+k*j)%(i+j)
        i += j
    ans += (n-i)*k
    return ans

def main():
    n, k = map(int, input().split())
    print(n) if k == 1 else print(josephus(n,k)+1)
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll josephus(ll n, ll k){
    if(n == 1) return 0;
    if(n < k) return (josephus(n-1, k)+k)%n;
    ll l = josephus(n-n/k, k) - n%k;
    if(l < 0) return l+n;
    return l+l/(k-1);
}

int main(){
    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);
    ll n, k; cin >> n >> k; if(k == 1) cout << n; else cout << josephus(n, k)+1;
}
```
