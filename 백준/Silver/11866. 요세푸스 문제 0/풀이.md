# 풀이
## 요세푸스의 문제(순열) 배경
<img width="295" height="294" alt="다운로드" src="https://github.com/user-attachments/assets/6539559b-bed3-47a6-abfc-32221e6361c9" align="center"/>


유대인 역사가 플라비우스 요세푸스가 겪은 경험을 바탕으로 만들어진 문제이다.

당시 예루살렘에서 살았던 요세푸스는 유대-로마 전쟁 때 유대군 장교로 참전했다가 동료 병사들, 자신을 포함해 총 41명과 함께 요타파타[1]에서 서기 70년에 황제가 될 베스파시아누스가 지휘하는 로마군에게 포위되었고, 동료들은 로마군의 손에 죽느니 스스로 죽겠다고 집단자살하기로 했다. 그러나 직접 자살하는 것이 어려웠는지, 그들은 서로 죽이기 위한 알고리즘을 세운다. 요세푸스를 따라온 동료들은 위의 그림과는 다르게 2명 살리고 한 명 죽이는 식으로 자살했다.[2] 그러나 요세푸스는 동료들의 뜻에 반대하고 살고 싶었고, 수학적 논리력을 발휘하여 끝까지 살기 위한 자리를 찾아서 결국 살아남아 베스파시아누스에게 항복했다.

## 풀이
큐를 이용하면 손쉽게 해결이 가능합니다. 큐 앞에서 하나씩 꺼내서 살 사람의 번호는 큐의 뒤로 다시 보내고 죽을 사람의 번호는 출력합니다.

파이썬에선 메서드 rotate()를 쓰면 좀 더 쉽고 빠르게 구현이 가능합니다.
## 문제 유형
* 구현, 자료 구조, 큐
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N \times K)$
* 공간복잡도: $\mathcal{O}(N)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

from collections import deque

def main():
    n, k = map(int, input().split())
    q = deque(list(range(1, n+1)))
    ans = []
    while q:
        # 왼쪽으로 (k-1)만큼 회전시켜 제거할 요소를 가장 앞으로 보냅니다.
        # 음수값은 왼쪽(시계 반대 방향) 회전을 의미합니다.
        q.rotate(-(k-1))
        ans.append(str(q.popleft()))
    print(f'<{", ".join(ans)}>')
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, k; cin >> n >> k;
    queue<int> q;
    for(int i = 1; i <= n; i++) q.push(i);
    cout << "<";
    while(!q.empty()){
        for(int j = 0; j < k-1; j++){
            q.push(q.front());
            q.pop();
        }
        cout << q.front();
        q.pop();
        if(!q.empty()) cout << ", ";
    }
    cout << ">";
    return 0;
}
```
