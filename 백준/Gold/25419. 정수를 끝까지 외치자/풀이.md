## 풀이
* **dp[x] = 현재 숫자가 x일 때, 지금 차례인 사람이 이길 수 있는가** 
* 이 문제는 n 정해질 때 어느정도 승패가 결정나는 게임입니다.
* 그렇다면 n부터 이길 수 있는지를 dp에 기록해 갑니다.
* y = x+1 ~ x+k(y ≤ n, y가 금지 숫자 아님) 라고 한다면 y의 범위 안에 dp[y] == false이 하나라도 있으면 dp[x]=true가 됩니다.
* 첫 학생이 이길 수 있는지 조사해야 하기 떄문에 1~k+1범위를 동일한 방법으로 dp[i] 기록을 보고 정답을 냅니다.
## 문제 유형
* Game DP (승패 DP)
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n·k)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def main():
    n, k = map(int, input().split())
    blocked_list = list(map(int, input().split()))

    dp = [False] * (n + 1)
    blocked = [False] * (n + 1)
    
    for b in blocked_list:
        if b <= n:
            blocked[b] = True

    for x in range(n, -1, -1):
        for d in range(1, k+1):
            y = x + d
            if y > n:
                continue
            if blocked[y]:
                continue
            if not dp[y]:
                dp[x] = True
                break

    for i in range(1, k + 1):
        if i > n:
            continue
        if blocked[i]:
            continue
        if not dp[i]:
            print(1)
            return
    print(0)

if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n, k; cin >> n >> k;
    cin.ignore(); 

    vector<bool> dp(n + 1, false);
    vector<bool> blocked(n + 1, false);   

    string line;
    getline(cin, line);
    stringstream ss(line);
    int b;
    while (ss >> b) {
        if (b <= n) {
            blocked[b] = true;
        }
    }

    for (int x = n; x > -1; x--){
        for (int d = 1; d < k+1; d++){
            int y= x + d;
            if (y>n) continue;
            if (blocked[y]) continue;
            if (!dp[y]){
                dp[x] = true;
                break;
            }
        }
    }

    for (int i = 1; i < k+1; i++){
        if (i > n) continue;
        if (blocked[i]) continue;
        if (!dp[i]){
            cout << 1;
            return 0;
        }
    }
    
    cout << 0;
    return 0;
}
```
