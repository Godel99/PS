## 풀이
### 그래프 만들기
* 입력 데이트를 인접리스트 그래프로 일단 만듭니다.
### 지름 구하기
* 어느 한 노드를 정해서 DFS로 그 노드에서 갈 수 있는 최대한 먼 노드까지 갑니다.
* 그 뒤 다시 DFS를 이용해 가장 먼 노드까지 가서 최종 지름을 구합니다.
### 지름+지름+간선 최대값 구하기
* 이제 모든 간선에 대해서 지름을 구하고 거기서 최댓값을 구하면 그게 정답입니다.
## 문제 유형
* 그래프 이론, 브루트포스 알고리즘, 그래프 탐색, 트리, 깊이 우선 탐색
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N²)$
* 공간복잡도: $\mathcal{O}(N)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def main():
    N = int(input())
    graph = [[] for _ in range(N)]
    edges = []

    for _ in range(N-1):
        u, v, w = map(int, input().split())
        edges.append((u, v, w))
        graph[u].append((v, w))
        graph[v].append((u, w))
    
    def DFS(start, pre, blocked_edge):
        visited = [False] * N
        stack = [(start, 0)]
        visited[start] = True

        node = start
        max_dist = 0
        while stack:
            cur, dist = stack.pop()

            if dist > max_dist:
                max_dist = dist
                node = cur

            for nxt, w in graph[cur]:
                if nxt == pre:
                    continue
                if nxt == blocked_edge:
                    continue
                if not visited[nxt]:
                    visited[nxt] = True
                    stack.append((nxt, dist + w))

        return node, max_dist

    answer = 0
    for u, v, w in edges:
        answer = max(answer, DFS(DFS(u, v, v)[0], v, v)[1] + w + DFS(DFS(v, u, u)[0], u, u)[1])

    print(answer)

if __name__ == '__main__':
    main()

```
### C++
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pll = pair<ll, ll>;

int N;
vector<vector<pll>> graph;
vector<tuple<int, int, int>> edges;

pll DFS(int start, int pre, int blocked_edge){
    vector<bool> visited(N, false);
    stack<pll> st;

    st.push({start, 0});
    visited[start] = true;

    int node = start;
    ll max_dist = 0;

    while (!st.empty()){
        auto [cur, dist] = st.top(); st.pop();

        if (dist > max_dist){
            max_dist = dist;
            node = cur;
        }

        for (auto [nxt, w] : graph[cur]) {
            if (nxt == pre) continue;
            if (nxt == blocked_edge) continue;
            if (!visited[nxt]){
                visited[nxt] = true;
                st.push({nxt, dist + w});
            }
        }
    }
    return {node, max_dist};
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    cin >> N;
    graph.resize(N);

    for (int i = 0; i < N-1; i++){
        int u, v; ll w;
        cin >> u >> v >> w;
        edges.push_back({u,v,w});
        graph[u].push_back({v,w});
        graph[v].push_back({u,w});
    }

    ll answer = 0;

    for (auto [u,v,w] : edges){
        answer = max(answer, DFS(DFS(u,v,v).first, v, v).second + w + DFS(DFS(v,u,u).first, u,u).second);
    }

    cout << answer;
}
```
