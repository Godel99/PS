## 풀이
* 핵심은 좌우로 자신보다 작은 값이 없으면 그 풍선은 살아남는다는 것입니다.
* 그래서 첫번째와 마지막 풍선은 무조건 살아남습니다.
* 왼쪽을 기준으로 더 작은 풍선이 발견되면 그 풍선을 살아남는 것으로 봅니다.
* 오른쪽도 마찬가지로 하며 중복을 set으로 처리해 그 길이가 정답입니다.
## 문제 유형
* Prefix / Suffix Preprocessing
* Greedy
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def solution(a):
    n = len(a)
    if n <= 2:
        return n
    
    survive = set()
    cur_min = float('inf')
    for i in range(n):
        if a[i] < cur_min:
            cur_min = a[i]
            survive.add(i)

    cur_min = float('inf')
    for i in range(n-1, -1, -1):
        if a[i] < cur_min:
            cur_min = a[i]
            survive.add(i)
    
    return len(survive)

def main():
    print(solution([-16,27,65,-2,58,-92,-71,-68,-61,-33]))
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int solution(vector<int> a) {
    int n = a.size();
    if (n <= 2) return n;

    unordered_set<int> survive;

    int cur_min = INT_MAX;
    for (int i = 0; i < n; i++){
        if (a[i] < cur_min){
            cur_min = a[i];
            survive.insert(i);
        }
    }

    cur_min = INT_MAX;
    for (int i = n-1; i > -1; i--){
        if (a[i] < cur_min){
            cur_min = a[i];
            survive.insert(i);
        }
    }

    return survive.size();
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    cout << solution({-16,27,65,-2,58,-92,-71,-68,-61,-33});
}
```
