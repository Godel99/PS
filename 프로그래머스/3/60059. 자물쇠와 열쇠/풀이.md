# 풀이
### lock 배열 늘리기
key 배열을 lock 배열 위에서 움직여가며 매번 배치가 맞는지 확인해야 합니다. 문제는 key 배열이 lock 배열 범위를 벗어날 수도 있다는 점입니다. 그래서 lock 배열의 행과 열을 **3배**로 늘려서 key 배열을 움직이면 이 문제를 해결할 수 있습니다.
### 로테이션 함수 만들기
2차원 배열에서 로테이션을 하기 위해선 공식을 써야 합니다. $90^\circ$ 회전을 위해서는 $rot[i][j] = key[M - j - 1][i]$ 식을 적용하면 됩니다. $180^\circ$ 이상은 로테이션 함수를 여러번 반복해서 부르면 됩니다.

그 다음은 간단히 확장된 lock 배열에 key 값을 한번씩 움직이고 회전하고 더하고 확인 후 다시 빼주기를 반복합니다.
## 문제 유형
* Brute Force (완전 탐색), Simulation (시뮬레이션)
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(N^2 \cdot M^2)$
* 공간복잡도: $\mathcal{O}(N^2)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def rotate(key):
    n = len(key)
    nk = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            nk[j][n-1-i] = key[i][j]
    return nk

def isopen(n, board):
    for i in range(n, 2*n):
        for j in range(n, 2*n):
            if board[i][j] != 1: return False
    return True

def solution(key, lock):
    n, m =  len(lock), len(key)
    board = [[0] * n*3 for _ in range(n*3)]
    for i in range(n):
        for j in range(n):
            board[i+n][j+n] = lock[i][j]
    cur = key
    for _ in range(4):
        for x in range(2*n+1):
            for y in range(2*n+1):
                for i in range(m):
                    for j in range(m):
                        board[x+i][y+j] += cur[i][j]
                if isopen(n, board): return True
                for i in range(m):
                    for j in range(m):
                        board[x+i][y+j] -= cur[i][j]
        cur = rotate(cur)
    return False
def main():
    print(solution([[0, 0, 0], [1, 0, 0], [0, 1, 1]],	[[1, 1, 1], [1, 1, 0], [1, 0, 1]]))
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

vector<vector<int>> rotate(vector<vector<int>> key){
    int n = key.size();
    vector<vector<int>> nk(n, vector<int>(n, 0));
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++) nk[j][n-1-i] = key[i][j];
    }
    return nk;
}

bool isopen(int n, vector<vector<int>> board){
    for(int i = n; i < 2*n; i++){
        for(int j = n; j < 2*n; j++){
            if(board[i][j] != 1) return false;
        }
    }
    return true;
}

bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    int n, m; n = lock.size(); m = key.size();
    vector<vector<int>> board(n*3, vector<int>(n*3, 0));
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++) board[i+n][j+n] = lock[i][j];
    }
    vector<vector<int>> cur = key;
    for(int r = 0; r < 4; r++){
        for(int x = 0; x < 2*n+1; x++){
            for(int y = 0; y < 2*n+1; y++){
                for(int i = 0; i < m; i++){
                    for(int j = 0; j < m; j++) board[x+i][y+j] += cur[i][j];
                }
                if(isopen(n, board)) return true;
                for(int i = 0; i < m; i++){
                    for(int j = 0; j < m; j++) board[x+i][y+j] -= cur[i][j];
                }
            }
        }
        cur = rotate(cur);
    }
    return false;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    return 0;
}
```
