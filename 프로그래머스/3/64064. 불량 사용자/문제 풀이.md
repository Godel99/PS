# 문제 풀이

## 해결 과정
1. 불량 유저의 패턴에 매칭되는 아이디 리스트를 만든다.
2. 각 패턴마다 올 수 있는 아이디를 모두 집합으로 묶는다.(순서는 상관 없고 중복은 제거)
3. 그 집합의 개수를 반환한다.
## 사용된 자료구조 및 알고리즘
* DFS
* Hash

## 코드 설명
### 전체 코드
```python
def solution(user_id, banned_id):
    def is_match(user, banned):
        if len(user) != len(banned):
            return False
        return all(b == '*' or b == u for u, b in zip(user, banned))

    pattern_id = []
    for banned in banned_id:
        pattern = [user for user in user_id if is_match(user, banned)]
        pattern_id.append(pattern)

    result = set()
    chosen = set()

    def DFS(depth):
        if depth == len(pattern_id):
            result.add(frozenset(chosen))
            return
        
        for id in pattern_id[depth]:
            if id not in chosen:
                chosen.add(id)
                DFS(depth+1)
                chosen.remove(id)

    DFS(0)

    return len(result)
```
***
```python
def is_match(user, banned):
    if len(user) != len(banned):
        return False
    return all(b == '*' or b == u for u, b in zip(user, banned))
```
**is_match: 불량 아이디와 유저 아이디가 매칭하는지 판별 후 참/거짓을 반환하는 함수**
```
all(iterable)
```
* 모든 요소가 True일 때: True 반환
* 요소 중 하나라도 False일 때: False 반환
* 빈 객체(Empty)일 때: True 반환 (주의: 비어 있으면 '거짓인 요소가 하나도 없으므로' True입니다.)

***
```python
def DFS(depth):
    if depth == len(pattern_id):
        result.add(frozenset(chosen))
        return
    
    for id in pattern_id[depth]:
        if id not in chosen:
            chosen.add(id)
            DFS(depth+1)
            chosen.remove(id) # backtracking
```
**DFS: 깊이 탐색을 통해서 패턴과 일치하는 아이디 집합을 만드는 함수**
* **DFS(깊이 우선 탐색)**
DFS는 그래프나 트리에서 한 방향으로 갈 수 있는 곳까지 최대한 깊게 들어갔다가, 더 이상 갈 곳이 없으면 가장 마지막 갈림길로 돌아와서 다른 방향을 탐색하는 방식입니다.

동작 원리: 스택(Stack) 자료구조 또는 재귀 함수를 이용합니다.

특징:

모든 노드를 방문하고자 할 때 주로 사용합니다.

BFS보다 속도는 느릴 수 있지만, 메모리 소모가 상대적으로 적습니다.

경로의 특징을 저장해야 하는 문제(예: 경로에 특정 숫자가 있어야 함)에 적합합니다.
* **BFS(너비 우선 탐색)**
BFS는 현재 위치에서 인접한 노드들을 먼저 모두 방문한 뒤, 그다음 레벨로 넘어가는 방식입니다. 마치 물결이 퍼져나가는 것과 비슷합니다.

동작 원리: 큐(Queue) 자료구조를 이용합니다.

특징:

최단 경로를 찾는 문제에서 매우 효율적입니다. (가까운 곳부터 찾기 때문에 처음 발견한 목표가 곧 최단 거리입니다.)
```python
frozenset
```
* frozenset은 이름에서 알 수 있듯이 **"얼려진(frozen)" set**입니다. 일반적인 set과 동일한 특성을 가지지만, 한 번 생성하면 요소를 추가하거나 삭제할 수 없는 불변(Immutable) 자료형입니다.
* 왜 frozenset을 사용하나요? (효율적 활용처) 가장 큰 이유는 **"값이 변하지 않음을 보장"**해야 하거나 **"해시(Hash) 가능한 객체"**가 필요할 때입니다.
1. 딕셔너리의 키(Key)로 사용
2. 집합 안에 집합 넣기 (Nested Set)

* DFS 깊이 탐색은 위 코드처럼 재귀나 stack(deque)를 이용해 구현 할 수 있다. 중요한 건 backtrack을 이용해 되돌아와서 원상복구를 해줘야 한다.

