# 풀이
* 입력을 그래프로 변환합니다.
* 힙과 다익스트라 알고리즘을 이용해서 모든 구간에서의 최소 비용을 구해 dist에 기록합니다.
* 시작점과 도착점A, B점에서의 최소 비용을 구한 후 그 비용을 모두 더한 합이 최소가 되는 비용이 정답이 됩니다.
```
distS[k]+distA[k]+distB[k] : K점까지의 총 최소 비용
```
## 문제 유형
* Heap + 다익스트라, 그래프
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(V + E) log V)$
* 공간복잡도: $\mathcal{O}(V + E)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

import heapq
INF = int(1e9)

def dijkstra(s, n, g):
    dist = [INF] * (n+1)
    dist[s] = 0
    pq = [(0, s)]
    while pq:
        cost, cur = heapq.heappop(pq)
        if cost > dist[cur]: continue
        for nxt, w in g[cur]:
            if dist[nxt] > cost+w:
                dist[nxt] = cost+w
                heapq.heappush(pq, (dist[nxt], nxt))
    return dist

def solution(n, s, a, b, fares):
    graph = [[] for _ in range(n+1)]
    for u, v, w in fares:
        graph[u].append((v, w))
        graph[v].append((u, w))
    distS = dijkstra(s, n, graph)
    distA = dijkstra(a, n, graph)
    distB = dijkstra(b, n, graph)
    ans = INF
    for k in range(1, n+1):
        if distS[k] == INF or distA == INF or distB == INF: continue
        ans = min(ans, distS[k]+distA[k]+distB[k])
    return ans

def main():
    print(solution(6,	4,	6,	2,	[[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]))
if __name__ == '__main__':
    main()
```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
const int INF = 1e9;

vector<int> dijkstra(int s, int n, vector<vector<pii>>& g){
    vector<int> dist(n+1, INF);
    dist[s] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, s});
    while(!pq.empty()){
        auto [cost, cur] = pq.top();
        pq.pop();
        if(cost > dist[cur]) continue;
        for(auto [nxt, w] : g[cur]){
            if(dist[nxt] > cost+w){
                dist[nxt] = cost+w;
                pq.push({dist[nxt], nxt});
            }
        }
    }
    return dist;
}

int solution(int n, int s, int a, int b, vector<vector<int>> fares){
    vector<vector<pii>> graph(n+1);
    for (auto &f : fares){
        int u = f[0], v = f[1], w = f[2];
        graph[u].push_back({v, w});
        graph[v].push_back({u, w});
    }
    vector<int> distS = dijkstra(s, n, graph);
    vector<int> distA = dijkstra(a, n, graph);
    vector<int> distB = dijkstra(b, n, graph);
    int ans = INF;
    for(int k = 1; k <= n; k++){
        if (distS[k] == INF || distA[k] == INF || distB[k] == INF) continue;
        ans = min(ans, distS[k]+distA[k]+distB[k]);
    }
    return ans;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    return 0;
}
```
