## 풀이
* 여러가지 풀이 방법이 있는데 가장 빠른 방법인 BFS 방법으로 풀었습니다.
* 접근은 “이 선수의 순위가 확정되는가?”부터 생각해봐야 합니다.
* 핵심은 **이긴 판수 + 진 판수 == n - 1** 성립하면 순위가 확정됩니다.
* 입력 데이터를 가지고 그래프를 구성합니다.
* BFS를 이용해 그래프를 돌면서 이긴 판수와 진 판수를 개수를 구해 반환합니다.
* **이긴 판수 + 진 판수 == n - 1**로 확정된 인원수가 정답입니다.
## 문제 유형
* 그래프, BFS, 플로이드–워셜, 비트셋
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n(n+e))$
* 공간복잡도: $\mathcal{O}(n^2)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

from collections import deque

def solution(n, results):
    graph = [[] for _ in range(n)]
    r_graph = [[] for _ in range(n)]

    for a, b in results:
        a -= 1; b -= 1
        graph[a].append(b)
        r_graph[b].append(a)

    def BFS(start, g):
        visited = [False] * n
        q = deque([start])
        visited[start] = True
        cnt = 0

        while q:
            cur = q.popleft()
            for nxt in g[cur]:
                if not visited[nxt]:
                    visited[nxt] = True
                    q.append(nxt)
                    cnt += 1

        return cnt
    ans = 0
    for i in range(n):
        win = BFS(i, graph)
        loss = BFS(i, r_graph)

        if win + loss == n - 1:
            ans += 1

    return ans
def main():
    print(solution(5,	[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]))
if __name__ == '__main__':
    main()
```
### 플로이드–워셜 방법
```python
def solution(n, results):
    win = [[False] * n for _ in range(n)]
    for i, j in results:
        win[i-1][j-1] = True
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if win[i][k] and win[k][j]:
                    win[i][j] = True
    cnt = 0
    for i in range(n):
        w = 0; l = 0
        for j in range(n):
            w += win[i][j]
            l += win[j][i]
        if w + l == n - 1:
            cnt += 1
    return cnt
```
### C++(비트셋 + 플로이드–워셜)
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int solution(int n, vector<vector<int>> results) {
    vector<bitset<101>> win(n);
    for(auto &r : results){
        int a = r[0] - 1;
        int b = r[1] - 1;
        win[a][b] = 1;
    }
    for(int k = 0; k < n; k++){
        for(int i = 0; i < n; i++){
            if(win[i][k]) win[i] |= win[k];
        }
    }
    int ans = 0;
    for(int i = 0; i < n; i++){
        int wins = win[i].count();
        int losses = 0;

        for(int j = 0; j < n; j++){
            if(win[j][i]) losses++;
        }
        
        if(wins + losses == n - 1) ans++;
    }
    return ans;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    return 0;
}
```
