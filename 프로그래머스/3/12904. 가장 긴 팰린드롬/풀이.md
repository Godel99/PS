## 풀이
* 팰린드롬의 짝수와 홀수의 경우를 나눠서 길이 계산
* 조심해야 할 사항은 i를 1씩 증가하며 뒤에 있을지도 모를 더 긴 팰린드롬을 찾아내야 함
## 자료구조 및 알고리즘
* Manacher
## 문제 유형
* 문자열+중심확장
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n²)$
* 공간복잡도: $\mathcal{O}(1)$
## 코드
```python
def solution(s):
    n = len(s)
    def expand(left, right):
        while left >= 0 and right < n and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
    
    max_len = 1
    for i in range(n):
        odd_len = expand(i, i)
        even_len = expand(i, i+1)
        max_len = max(max_len, odd_len, even_len)

    return max_len
```
## 다른 코드(Manacher)
```python
def solution(s):
    # 1. 문자 사이에 #을 삽입하여 전처리 (홀수/짝수 통일)
    # "aba" -> "#a#b#a#"
    # "abba" -> "#a#b#b#a#"
    t = '#'.join('^{}$'.format(s))
    n = len(t)
    
    # p[i]: i를 중심으로 하는 팰린드롬의 반지름
    p = [0] * n
    center = right = 0
    
    for i in range(1, n - 1):
        # 2. 대칭 위치의 값을 활용한 초기화
        mirror = 2 * center - i
        
        if i < right:
            p[i] = min(right - i, p[mirror])
        
        # 3. 중심 확장
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
        
        # 4. 오른쪽 경계 갱신
        if i + p[i] > right:
            center, right = i, i + p[i]
    
    # 5. 최대 길이 반환
    return max(p)
```
* 시간복잡도: $\mathcal{O}(n)$
* 공간복잡도: $\mathcal{O}(n)$
* 핵심은 중심확장을 중복하지 않아서 시간복잡도를 줄일 수 있음
