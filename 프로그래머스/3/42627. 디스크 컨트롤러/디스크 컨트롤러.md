## 풀이
* 요청시간순으로 jobs를 정렬
* 전체 작업이 처리될 때까지 반복
* 현재까지 도착한 모든 작업 수집
* (수집 할 때 튜플로 작업 순서를 정함)
* 살향할 작업이 있는지 확인 후 있다면 작업 수행
* 작업이 없다면 현재 시간을 다음 작업 요청 시간으로 이동
## 자료구조 및 알고리즘
* Heap
## 문제 유형
* 시뮬레이션
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n log n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
```python
import heapq

def solution(jobs): 
    jobs.sort()
    n = len(jobs)

    cur_time = idx = total_time = 0
    pq = []

    while idx < n or pq:
        while idx < n and jobs[idx][0] <= cur_time:
            start, duration = jobs[idx]
            heapq.heappush(pq, (duration, start))
            idx += 1

        if pq:
            duration, start = heapq.heappop(pq)
            cur_time += duration
            total_time += (cur_time - start)
        else:
            cur_time = jobs[idx][0]

    return total_time // n
```
